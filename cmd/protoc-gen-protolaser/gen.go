package main

import (
	"fmt"
	"path/filepath"
	"slices"
	"strings"

	"golang.org/x/exp/maps"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile generates a .laser.go file containing a HTTP handler that serves the RPCs.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".laser.go"
	g := gen.NewGeneratedFile(filepath.Base(filename), file.GoImportPath)
	g.P("// Code generated by protoc-gen-protolaser. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)

	structNames := map[*protogen.Message]string{}
	for m, external := range allMessages(file) {
		name := m.GoIdent.GoName + "_filter"
		if external {
			name = "external_" + name
		}
		structNames[m] = name
	}

	orderedMessages := maps.Keys(structNames)
	slices.SortFunc(orderedMessages, func(a, b *protogen.Message) int {
		return strings.Compare(structNames[a], structNames[b])
	})

	for _, m := range orderedMessages {
		name := structNames[m]
		g.P("// ", name, " can match against protobuf wire format of ", m.GoIdent.GoName, ".")
		if strings.HasPrefix(name, "external_") {
			g.P("// ", m.GoIdent.GoName, " is actually defined in ", string(m.GoIdent.GoImportPath), ". Because we don't know if protolaser generated code for it, we just generate it here.")
		}
		g.P("type ", name, " struct {")
		g.P("	", protogen.GoIdent{"MessageFilter", "github.com/hexon/protolaser"})
		g.P("}")

	fieldloop:
		for _, f := range m.Fields {
			if f.Desc.IsMap() || f.Desc.IsList() {
				continue
			}
			var goType any
			var typeName string
			var cast string
			var defaultValue any
			switch f.Desc.Kind() {
			case protoreflect.BoolKind:
				goType = "bool"
				typeName = "Bool"
				defaultValue = f.Desc.Default().Bool()
			case protoreflect.EnumKind:
				goType = f.Enum.GoIdent
				typeName = "Int32"
				cast = "int32"
				defaultValue = int64(f.Desc.Default().Enum())
			case protoreflect.StringKind:
				goType = "string"
				typeName = "String"
				defaultValue = f.Desc.Default().String()
			case protoreflect.BytesKind:
				goType = "[]byte"
				typeName = "Bytes"
				defaultValue = f.Desc.Default().Bytes()
			case protoreflect.Uint32Kind:
				goType = "uint32"
				typeName = "UnsignedInt"
				cast = "uint64"
				defaultValue = f.Desc.Default().Uint()
			case protoreflect.Uint64Kind:
				goType = "uint64"
				typeName = "UnsignedInt"
				defaultValue = f.Desc.Default().Uint()
			case protoreflect.Int32Kind, protoreflect.Fixed32Kind:
				goType = "int32"
				typeName = "Int32"
				defaultValue = f.Desc.Default().Int()
			case protoreflect.Int64Kind, protoreflect.Fixed64Kind:
				goType = "int64"
				typeName = "Int64"
				defaultValue = f.Desc.Default().Int()
			case protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
				goType = "int32"
				typeName = "SignedInt"
				cast = "int64"
				defaultValue = f.Desc.Default().Int()
			case protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
				goType = "int64"
				typeName = "SignedInt"
				defaultValue = f.Desc.Default().Int()
			case protoreflect.FloatKind:
				goType = "float32"
				typeName = "Float32"
				defaultValue = f.Desc.Default().Float()
			case protoreflect.DoubleKind:
				goType = "float64"
				typeName = "Float64"
				defaultValue = f.Desc.Default().Float()
			case protoreflect.MessageKind:
				child := structNames[f.Message]
				g.P("// Filter", f.GoName, " changes the filter to descend into field ", f.Desc.Name(), ".")
				g.P("func (f *", name, ") Filter", f.GoName, "() *", child, "{")
				g.P("	if sub, ok := f.Internal__GetFilter(", f.Desc.Number(), ").(*", child, "); ok {")
				g.P("		return sub")
				g.P("	}")
				g.P("	c := &", child, "{}")
				g.P("	f.Internal__CustomMessageFilter(", f.Desc.Number(), ", c)")
				g.P("	return c")
				g.P("}")
				continue fieldloop
			default:
				continue fieldloop
			}
			var defaultCheck string
			switch defaultValue := defaultValue.(type) {
			case bool:
				if defaultValue {
					defaultCheck = "v"
				} else {
					defaultCheck = "!v"
				}
			case []byte:
				if len(defaultValue) == 0 {
					defaultCheck = "len(v) == 0"
				} else {
					defaultCheck = fmt.Sprintf("bytes.Equal(v, []byte(%q)", defaultValue)
				}
			case string:
				defaultCheck = fmt.Sprintf("v == %q", defaultValue)
			case int64, uint64, float64:
				defaultCheck = fmt.Sprintf("v == %v", defaultValue)
			default:
				panic(fmt.Errorf("Don't know how to handle default value of type %T", defaultValue))
			}
			if f.Desc.HasOptionalKeyword() {
				defaultCheck = "false"
			}
			val := "v"
			if cast != "" {
				val = cast + "(v)"
			}
			g.P("// ", f.GoName, "Equals changes the filter to require value v for field ", f.Desc.Name(), ".")
			g.P("func (f *", name, ") ", f.GoName, "Equals(v ", goType, ") {")
			g.P("	f.Equal", typeName, "(", f.Desc.Number(), ", ", val, ",", defaultCheck, ")")
			g.P("}")

			switch f.Desc.Kind() {
			case protoreflect.EnumKind, protoreflect.Uint32Kind, protoreflect.Uint64Kind, protoreflect.Int32Kind, protoreflect.Fixed32Kind, protoreflect.Int64Kind, protoreflect.Fixed64Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind, protoreflect.FloatKind, protoreflect.DoubleKind:
				g.P("// ", f.GoName, "LessThan changes the filter to require field ", f.Desc.Name(), " to be at less than v.")
				g.P("func (f *", name, ") ", f.GoName, "LessThan(v ", goType, ") {")
				g.P("	f.LessThan", typeName, "(", f.Desc.Number(), ", ", val, ", ", defaultValue, " < v)")
				g.P("}")

				g.P("// ", f.GoName, "LessThan changes the filter to require field ", f.Desc.Name(), " to be at more than v.")
				g.P("func (f *", name, ") ", f.GoName, "GreaterThan(v ", goType, ") {")
				g.P("	f.GreaterThan", typeName, "(", f.Desc.Number(), ", ", val, ", ", defaultValue, " > v)")
				g.P("}")

				g.P("// ", f.GoName, "LessThan changes the filter to require field ", f.Desc.Name(), " to be at at most v.")
				g.P("func (f *", name, ") ", f.GoName, "LessEquals(v ", goType, ") {")
				g.P("	f.LessEqual", typeName, "(", f.Desc.Number(), ", ", val, ", ", defaultValue, " <= v)")
				g.P("}")

				g.P("// ", f.GoName, "LessThan changes the filter to require field ", f.Desc.Name(), " to be at at least v.")
				g.P("func (f *", name, ") ", f.GoName, "GreaterEquals(v ", goType, ") {")
				g.P("	f.GreaterEqual", typeName, "(", f.Desc.Number(), ", ", val, ", ", defaultValue, " >= v)")
				g.P("}")
			}

			if f.Desc.Kind() != protoreflect.BoolKind {
				val := "vs"
				g.P("// ", f.GoName, "In changes the filter to require one of the given values for field ", f.Desc.Name(), ".")
				g.P("func (f *", name, ") ", f.GoName, "In(vs []", goType, ") {")
				g.P("matchIfMissing := false")
				if cast != "" {
					g.P("converted := make([]", cast, ", len(vs))")
					g.P("for i, v := range vs {")
					g.P("	converted[i] = ", cast, "(v)")
					g.P("	if ", defaultCheck, " {")
					g.P("		matchIfMissing = true")
					g.P("	}")
					g.P("}")
					val = "converted"
				} else {
					g.P("for _, v := range vs {")
					g.P("	if ", defaultCheck, " {")
					g.P("		matchIfMissing = true")
					g.P("		break")
					g.P("	}")
					g.P("}")
				}
				g.P("	f.", typeName, "In(", f.Desc.Number(), ", ", val, ", matchIfMissing)")
				g.P("}")
			}

			g.P("// Extract", f.GoName, " changes the filter to call cb(v) if it encounters field ", f.Desc.Name(), ".")
			g.P("func (f *", name, ") Extract", f.GoName, "(cb func(", goType, ") error) {")
			if cast != "" {
				g.P("	f.Extract", typeName, "(", f.Desc.Number(), ", func(v ", cast, ") error {")
				g.P("		return cb(", goType, "(v))")
				g.P("	})")
			} else {
				g.P("	f.Extract", typeName, "(", f.Desc.Number(), ", cb)")
			}
			g.P("}")
		}
	}
}

func allMessages(file *protogen.File) map[*protogen.Message]bool {
	seen := map[*protogen.Message]bool{}
	for _, m := range file.Messages {
		descend(seen, m, false)
	}
	return seen
}

func descend(dst map[*protogen.Message]bool, m *protogen.Message, external bool) {
	if ext, ok := dst[m]; ok && (!ext || external) {
		return
	}
	dst[m] = external
	for _, sub := range m.Messages {
		descend(dst, sub, external)
	}
	for _, f := range m.Fields {
		if f.Message != nil {
			descend(dst, f.Message, true)
		}
	}
}

/*
func ucfirst(s string) string {
	return unicode.ToUpper(s[0]) + s[1:]
}
*/
